"use strict";import U from"../Core/Utilities.js";var extend=U.extend,pick=U.pick,min=Math.min,max=Math.max,abs=Math.abs;function findLastObstacleBefore(t,n,a){for(var x,i,e=a||0,s=t.length-1,r=n-1e-7;e<=s;)if(0<(i=r-t[x=s+e>>1].xMin))e=1+x;else{if(!(i<0))return x;s=x-1}return 0<e?e-1:0}function pointWithinObstacle(t,n){return n.x<=t.xMax&&n.x>=t.xMin&&n.y<=t.yMax&&n.y>=t.yMin}function findObstacleFromPoint(t,n){for(var a=findLastObstacleBefore(t,n.x+1)+1;a--;)if(t[a].xMax>=n.x&&pointWithinObstacle(t[a],n))return a;return-1}function pathFromSegments(t){var n=[];if(t.length){n.push(["M",t[0].start.x,t[0].start.y]);for(var a=0;a<t.length;++a)n.push(["L",t[a].end.x,t[a].end.y])}return n}function limitObstacleToBounds(t,n){t.yMin=max(t.yMin,n.yMin),t.yMax=min(t.yMax,n.yMax),t.xMin=max(t.xMin,n.xMin),t.xMax=min(t.xMax,n.xMax)}function straight(t,n){return{path:[["M",t.x,t.y],["L",n.x,n.y]],obstacles:[{start:t,end:n}]}}var simpleConnect=function(t,n,a){var x,i,e=[],s=pick(a.startDirectionX,abs(n.x-t.x)>abs(n.y-t.y))?"x":"y",r=a.chartObstacles,o=findObstacleFromPoint(r,t),a=findObstacleFromPoint(r,n);function y(t,n,a,x,i){t={x:t.x,y:t.y};return t[n]=a[x||n]+(i||0),t}function M(t,n,a){var x=abs(n[a]-t[a+"Min"])>abs(n[a]-t[a+"Max"]);return y(n,a,t,a+(x?"Max":"Min"),x?1:-1)}return a=-1<a?(x={start:i=M(r[a],n,s),end:n},i):n,-1<o&&(i=M(o=r[o],t,s),e.push({start:t,end:i}),i[s]>=t[s]==i[s]>=a[s]&&(n=t[s="y"===s?"x":"y"]<n[s],e.push({start:i,end:y(i,s,o,s+(n?"Max":"Min"),n?1:-1)}),s="y"===s?"x":"y")),i=y(t=e.length?e[e.length-1].end:t,s,a),e.push({start:t,end:i}),a=y(i,s="y"===s?"x":"y",a),e.push({start:i,end:a}),e.push(x),{path:pathFromSegments(e),obstacles:e}};simpleConnect.requiresObstacles=!0;var fastAvoid=function(t,n,c){var a,x,i,e,s,r,o=pick(c.startDirectionX,abs(n.x-t.x)>abs(n.y-t.y)),y=o?"x":"y",M=[],d=!1,l=c.obstacleMetrics,u=min(t.x,n.x)-l.maxWidth-10,f=max(t.x,n.x)+l.maxWidth+10,m=min(t.y,n.y)-l.maxHeight-10,h=max(t.y,n.y)+l.maxHeight+10,b=c.chartObstacles,l=findLastObstacleBefore(b,u),p=findLastObstacleBefore(b,f);function O(t,n,a){for(var x,i,e=t.x<n.x?1:-1,s=t.x<n.x?(x=t,n):(x=n,t),r=t.y<n.y?(i=t,n):(i=n,t),o=e<0?min(findLastObstacleBefore(b,s.x),b.length-1):0;b[o]&&(0<e&&b[o].xMin<=s.x||e<0&&b[o].xMax>=x.x);){if(b[o].xMin<=s.x&&b[o].xMax>=x.x&&b[o].yMin<=r.y&&b[o].yMax>=i.y)return a?{y:t.y,x:t.x<n.x?b[o].xMin-1:b[o].xMax+1,obstacle:b[o]}:{x:t.x,y:t.y<n.y?b[o].yMin-1:b[o].yMax+1,obstacle:b[o]};o+=e}return n}function v(t,n,a,x,i){var e=i.soft,s=i.hard,r=x?"x":"y",o={x:n.x,y:n.y},y={x:n.x,y:n.y},M=t[r+"Max"]>=e[r+"Max"],c=t[r+"Min"]<=e[r+"Min"],d=t[r+"Max"]>=s[r+"Max"],i=t[r+"Min"]<=s[r+"Min"],e=abs(t[r+"Min"]-n[r]),s=abs(t[r+"Max"]-n[r]),e=abs(e-s)<10?n[r]<a[r]:s<e;return y[r]=t[r+"Min"],o[r]=t[r+"Max"],y=O(n,y,x)[r]!==y[r],r=O(n,o,x)[r]!==o[r],e=y?!r||e:!r&&e,e=c?!M||e:!M&&e,e=i?!d||e:!d&&e}for(-1<(p=findObstacleFromPoint(b=b.slice(l,p+1),n))&&(i=b[p],e=n,s=t,r=min(i.xMax-e.x,e.x-i.xMin)<min(i.yMax-e.y,e.y-i.yMin),s=v(i,e,s,r,{soft:c.hardBounds,hard:c.hardBounds}),x=r?{y:e.y,x:i[s?"xMax":"xMin"]+(s?1:-1)}:{x:e.x,y:i[s?"yMax":"yMin"]+(s?1:-1)},M.push({end:n,start:x}),n=x);-1<(p=findObstacleFromPoint(b,n));)a=n[y]-t[y]<0,(x={x:n.x,y:n.y})[y]=b[p][a?y+"Max":y+"Min"]+(a?1:-1),M.push({end:n,start:x}),n=x;return{path:pathFromSegments(o=(o=function t(n,a,x){if(n.x===a.x&&n.y===a.y)return[];var i,e,s,r=x?"x":"y",o=c.obstacleOptions.margin,y={soft:{xMin:u,xMax:f,yMin:m,yMax:h},hard:c.hardBounds},M=findObstacleFromPoint(b,n);return-1<M?(i=v(M=b[M],n,a,x,y),limitObstacleToBounds(M,c.hardBounds),s=x?{y:n.y,x:M[i?"xMax":"xMin"]+(i?1:-1)}:{x:n.x,y:M[i?"yMax":"yMin"]+(i?1:-1)},-1<(e=findObstacleFromPoint(b,s))&&(limitObstacleToBounds(e=b[e],c.hardBounds),s[r]=i?max(M[r+"Max"]-o+1,(e[r+"Min"]+M[r+"Max"])/2):min(M[r+"Min"]+o-1,(e[r+"Max"]+M[r+"Min"])/2),d=n.x===s.x&&n.y===s.y&&(d&&(s[r]=i?max(M[r+"Max"],e[r+"Max"])+1:min(M[r+"Min"],e[r+"Min"])-1),!d)),s=[{start:n,end:s}]):(s=[{start:n,end:{x:(n=O(n,{x:(x?a:n).x,y:(x?n:a).y},x)).x,y:n.y}}],n[x?"x":"y"]!==a[x?"x":"y"]&&(i=v(n.obstacle,n,a,!x,y),limitObstacleToBounds(n.obstacle,c.hardBounds),i={x:x?n.x:n.obstacle[i?"xMax":"xMin"]+(i?1:-1),y:x?n.obstacle[i?"yMax":"yMin"]+(i?1:-1):n.y},s=s.concat(t({x:n.x,y:n.y},i,x=!x)))),s=s.concat(t(s[s.length-1].end,a,!x))}(t,n,o)).concat(M.reverse())),obstacles:o}};fastAvoid.requiresObstacles=!0;var algorithms={fastAvoid:fastAvoid,straight:straight,simpleConnect:simpleConnect};export default algorithms;