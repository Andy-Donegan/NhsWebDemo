"use strict";import U from"../../Core/Utilities.js";var clamp=U.clamp,error=U.error,pick=U.pick;function GLShader(a){var t,r,n,l,f,u,x,s,b,m,c,d=["#version 100","#define LN10 2.302585092994046","precision highp float;","attribute vec4 aVertexPosition;","attribute vec4 aColor;","varying highp vec2 position;","varying highp vec4 vColor;","uniform mat4 uPMatrix;","uniform float pSize;","uniform float translatedThreshold;","uniform bool hasThreshold;","uniform bool skipTranslation;","uniform float xAxisTrans;","uniform float xAxisMin;","uniform float xAxisMinPad;","uniform float xAxisPointRange;","uniform float xAxisLen;","uniform bool  xAxisPostTranslate;","uniform float xAxisOrdinalSlope;","uniform float xAxisOrdinalOffset;","uniform float xAxisPos;","uniform bool  xAxisCVSCoord;","uniform bool  xAxisIsLog;","uniform bool  xAxisReversed;","uniform float yAxisTrans;","uniform float yAxisMin;","uniform float yAxisMinPad;","uniform float yAxisPointRange;","uniform float yAxisLen;","uniform bool  yAxisPostTranslate;","uniform float yAxisOrdinalSlope;","uniform float yAxisOrdinalOffset;","uniform float yAxisPos;","uniform bool  yAxisCVSCoord;","uniform bool  yAxisIsLog;","uniform bool  yAxisReversed;","uniform bool  isBubble;","uniform bool  bubbleSizeByArea;","uniform float bubbleZMin;","uniform float bubbleZMax;","uniform float bubbleZThreshold;","uniform float bubbleMinSize;","uniform float bubbleMaxSize;","uniform bool  bubbleSizeAbs;","uniform bool  isInverted;","float bubbleRadius(){","float value = aVertexPosition.w;","float zMax = bubbleZMax;","float zMin = bubbleZMin;","float radius = 0.0;","float pos = 0.0;","float zRange = zMax - zMin;","if (bubbleSizeAbs){","value = value - bubbleZThreshold;","zMax = max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);","zMin = 0.0;","}","if (value < zMin){","radius = bubbleZMin / 2.0 - 1.0;","} else {","pos = zRange > 0.0 ? (value - zMin) / zRange : 0.5;","if (bubbleSizeByArea && pos > 0.0){","pos = sqrt(pos);","}","radius = ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;","}","return radius * 2.0;","}","float translate(float val,","float pointPlacement,","float localA,","float localMin,","float minPixelPadding,","float pointRange,","float len,","bool  cvsCoord,","bool  isLog,","bool  reversed","){","float sign = 1.0;","float cvsOffset = 0.0;","if (cvsCoord) {","sign *= -1.0;","cvsOffset = len;","}","if (isLog) {","val = log(val) / LN10;","}","if (reversed) {","sign *= -1.0;","cvsOffset -= sign * len;","}","return sign * (val - localMin) * localA + cvsOffset + ","(sign * minPixelPadding);","}","float xToPixels(float value) {","if (skipTranslation){","return value;// + xAxisPos;","}","return translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord, xAxisIsLog, xAxisReversed);// + xAxisPos;","}","float yToPixels(float value, float checkTreshold) {","float v;","if (skipTranslation){","v = value;// + yAxisPos;","} else {","v = translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord, yAxisIsLog, yAxisReversed);// + yAxisPos;","if (v > yAxisLen) {","v = yAxisLen;","}","}","if (checkTreshold > 0.0 && hasThreshold) {","v = min(v, translatedThreshold);","}","return v;","}","void main(void) {","if (isBubble){","gl_PointSize = bubbleRadius();","} else {","gl_PointSize = pSize;","}","vColor = aColor;","if (skipTranslation && isInverted) {","gl_Position = uPMatrix * vec4(aVertexPosition.y + yAxisPos, aVertexPosition.x + xAxisPos, 0.0, 1.0);","} else if (isInverted) {","gl_Position = uPMatrix * vec4(yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, xToPixels(aVertexPosition.x) + xAxisPos, 0.0, 1.0);","} else {","gl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);","}","}"].join("\n"),v=["precision highp float;","uniform vec4 fillColor;","varying highp vec2 position;","varying highp vec4 vColor;","uniform sampler2D uSampler;","uniform bool isCircle;","uniform bool hasColor;","void main(void) {","vec4 col = fillColor;","vec4 tcol = texture2D(uSampler, gl_PointCoord.st);","if (hasColor) {","col = vColor;","}","if (isCircle) {","col *= tcol;","if (tcol.r < 0.0) {","discard;","} else {","gl_FragColor = col;","}","} else {","gl_FragColor = col;","}","}"].join("\n"),e={},A=[];function P(){A.length&&error("[highcharts boost] shader error - "+A.join("\n"))}function g(i,o){var e="vertex"===o?a.VERTEX_SHADER:a.FRAGMENT_SHADER,e=a.createShader(e);return a.shaderSource(e,i),a.compileShader(e),a.getShaderParameter(e,a.COMPILE_STATUS)?e:(A.push("when compiling "+o+" shader:\n"+a.getShaderInfoLog(e)),!1)}function i(){var i=g(d,"vertex"),o=g(v,"fragment");return i&&o?(t=a.createProgram(),a.attachShader(t,i),a.attachShader(t,o),a.linkProgram(t),a.getProgramParameter(t,a.LINK_STATUS)?(a.useProgram(t),a.bindAttribLocation(t,0,"aVertexPosition"),r=e("uPMatrix"),n=e("pSize"),l=e("fillColor"),f=e("isBubble"),u=e("bubbleSizeAbs"),x=e("bubbleSizeByArea"),c=e("uSampler"),s=e("skipTranslation"),b=e("isCircle"),m=e("isInverted"),!0):(A.push(a.getProgramInfoLog(t)),P(),t=!1)):(t=!1,P(),!1);function e(i){return a.getUniformLocation(t,i)}}function h(i,o){a&&t&&(i=e[i]=e[i]||a.getUniformLocation(t,i),a.uniform1f(i,o))}return!(a&&!i())&&{psUniform:function(){return n},pUniform:function(){return r},fillColorUniform:function(){return l},setBubbleUniforms:function(i,o,e){var r,n=i.options,l=Number.MAX_VALUE,s=-Number.MAX_VALUE;a&&t&&i.is("bubble")&&(r=i.getPxExtremes(),l=pick(n.zMin,clamp(o,!1===n.displayNegative?n.zThreshold:-Number.MAX_VALUE,l)),s=pick(n.zMax,Math.max(s,e)),a.uniform1i(f,1),a.uniform1i(b,1),a.uniform1i(x,"width"!==i.options.sizeBy),a.uniform1i(u,i.options.sizeByAbsoluteValue),h("bubbleZMin",l),h("bubbleZMax",s),h("bubbleZThreshold",i.options.zThreshold),h("bubbleMinSize",r.minPxSize),h("bubbleMaxSize",r.maxPxSize))},bind:function(){a&&t&&a.useProgram(t)},program:function(){return t},create:i,setUniform:h,setPMatrix:function(i){a&&t&&a.uniformMatrix4fv(r,!1,i)},setColor:function(i){a&&t&&a.uniform4f(l,i[0]/255,i[1]/255,i[2]/255,i[3])},setPointSize:function(i){a&&t&&a.uniform1f(n,i)},setSkipTranslation:function(i){a&&t&&a.uniform1i(s,!0===i?1:0)},setTexture:function(i){a&&t&&a.uniform1i(c,i)},setDrawAsCircle:function(i){a&&t&&a.uniform1i(b,i?1:0)},reset:function(){a&&t&&(a.uniform1i(f,0),a.uniform1i(b,0))},setInverted:function(i){a&&t&&a.uniform1i(m,i)},destroy:function(){a&&t&&(a.deleteProgram(t),t=!1)}}}export default GLShader;