"use strict";!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){t=t?t._modules:{};function e(t,e,a,r){t.hasOwnProperty(e)||(t[e]=r.apply(null,a))}e(t,"Extensions/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Chart/Chart.js"],t["Core/DefaultOptions.js"],t["Core/Series/Point.js"],t["Core/Series/Series.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Renderer/SVG/SVGRenderer.js"],t["Core/Utilities.js"],t["Core/Axis/Axis.js"]],function(t,e,a,r,i,o,n,s,l){var x=t.animObject,a=a.defaultOptions,o=o.seriesTypes,p=n.prototype.symbols,I=s.addEvent,Y=s.defined,S=s.error,b=s.isArray,A=s.isFunction,D=s.isObject,k=s.isNumber,v=s.merge,M=s.objectEach,X=s.relativeLength,g=s.syncTimeout,o=o.scatter,L=i.prototype.generatePoints,u=[],d=0,z={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}};(a.plotOptions||{}).series=v((a.plotOptions||{}).series,{cluster:z,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}});function P(t,e){var a=t.chart,r=t.xAxis,t=t.yAxis;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:r?r.toValue(e.x):0,y:t?t.toValue(e.y):0}}function E(t,e){var a=t.chart,r=t.xAxis,t=t.yAxis;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:r?r.toPixels(e.x):0,y:t?t.toPixels(e.y):0}}function w(t){for(var e=t.length,a=0,r=0,i=0;i<e;i++)a+=t[i].x,r+=t[i].y;return{x:a/e,y:r/e}}function h(t,e){var a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function c(t,e,a){t.attr({opacity:e}).animate({opacity:1},a)}function y(t,e,a,r,i){t.point&&(r&&t.point.graphic&&(t.point.graphic.show(),c(t.point.graphic,e,a)),i&&t.point.dataLabel&&(t.point.dataLabel.show(),c(t.point.dataLabel,e,a)))}function C(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function T(t,e,a,r){y(t,r,a,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}function O(){return Math.random().toString(36).substring(2,7)+"-"+d++}p.cluster=function(t,e,a,r){var i=a/2,o=r/2,a=p.arc(t+i,e+o,i-4,o-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),r=p.arc(t+i,e+o,i-3,o-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:i-2,open:!1});return p.arc(t+i,e+o,i-1,o-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:i,open:!1}).concat(r,a)},o.prototype.animateClusterPoint=function(t){var e,a,r=this.chart,i=r.mapView,o=this.options.cluster,n=x((o||{}).animation),s=n.duration||500,l=(this.markerClusterInfo||{}).pointsState,p=(l||{}).newState,u=(l||{}).oldState,d=[],h=0,c=0,f=!1,m=!1;u&&p&&(a=p[t.stateId],l=E(this,a),h=l.x-(i?0:r.plotLeft),c=l.y-(i?0:r.plotTop),1===a.parentsId.length?(t=(p||{})[t.stateId].parentsId[0],e=u[t],a.point&&a.point.graphic&&e&&e.point&&e.point.plotX&&e.point.plotY&&e.point.plotX!==a.point.plotX&&e.point.plotY!==a.point.plotY&&(t=a.point.graphic.getBBox(),o=a.point.graphic&&a.point.graphic.isImg?0:t.width/2,a.point.graphic.attr({x:e.point.plotX-o,y:e.point.plotY-o}),a.point.graphic.animate({x:h-(a.point.graphic.radius||0),y:c-(a.point.graphic.radius||0)},n,function(){m=!0,e.point&&e.point.destroy&&e.point.destroy()}),a.point.dataLabel&&a.point.dataLabel.alignAttr&&e.point.dataLabel&&e.point.dataLabel.alignAttr&&(a.point.dataLabel.attr({x:e.point.dataLabel.alignAttr.x,y:e.point.dataLabel.alignAttr.y}),a.point.dataLabel.animate({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y},n)))):0===a.parentsId.length?(C(a,!0,!0),g(function(){y(a,.1,n,!0,!0)},s/2)):(C(a,!0,!0),a.parentsId.forEach(function(t){u&&u[t]&&(e=u[t],d.push(e),e.point&&e.point.graphic&&(f=!0,e.point.graphic.show(),e.point.graphic.animate({x:h-(e.point.graphic.radius||0),y:c-(e.point.graphic.radius||0),opacity:.4},n,function(){m=!0,T(a,d,n,.7)}),e.point.dataLabel&&-9999!==e.point.dataLabel.y&&a.point&&a.point.dataLabel&&a.point.dataLabel.alignAttr&&(e.point.dataLabel.show(),e.point.dataLabel.animate({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y,opacity:.4},n))))}),g(function(){m||T(a,d,n,.85)},s),f||g(function(){T(a,d,n,.1)},s/2)))},o.prototype.getGridOffset=function(){var t=this,e=t.chart,a=t.xAxis,r=t.yAxis;return{plotLeft:a&&t.dataMinX&&t.dataMaxX?a.reversed?a.toPixels(t.dataMaxX):a.toPixels(t.dataMinX):e.plotLeft,plotTop:r&&t.dataMinY&&t.dataMaxY?r.reversed?r.toPixels(t.dataMinY):r.toPixels(t.dataMaxY):e.plotTop}},o.prototype.getScaledGridSize=function(t){var e=this,a=e.xAxis,r=this.chart.mapView,t=t.processedGridSize||z.layoutAlgorithm.gridSize,i=!0,o=1,n=1;e.gridValueSize||(e.gridValueSize=r?t/r.getScale():Math.abs(a.toValue(t)-a.toValue(0)));for(var s=+(t/(r?e.gridValueSize*r.getScale():a.toPixels(e.gridValueSize)-a.toPixels(0))).toFixed(14);i&&1!=s;){var l=Math.pow(2,o);.75<s&&s<1.25?i=!1:1/l<=s&&s<1/l*2?(i=!1,n=l):s<=l&&l/2<s&&(i=!1,n=1/l),o++}return t/n/s},o.prototype.getRealExtremes=function(){var t=this.chart,e=t.mapView?0:t.plotLeft,a=t.mapView?0:t.plotTop,r=P(this,{x:e,y:a}),a=P(this,{x:e+t.plotWidth,y:e+t.plotHeight}),e=r.x,t=a.x,r=r.y,a=a.y;return{minX:Math.min(e,t),maxX:Math.max(e,t),minY:Math.min(r,a),maxY:Math.max(r,a)}},o.prototype.onDrillToCluster=function(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){var e,a,r,i,o,n=t.point||t.target,s=n.series,l=n.series.xAxis,p=n.series.yAxis,u=n.series.chart,d=u.mapView;(s.options.cluster||{}).drillToCluster&&n.clusteredData&&(o=n.clusteredData.map(function(t){return t.x}).sort(function(t,e){return t-e}),r=n.clusteredData.map(function(t){return t.y}).sort(function(t,e){return t-e}),e=o[0],i=o[o.length-1],a=r[0],s=r[r.length-1],n=Math.abs(.1*(i-e)),o=Math.abs(.1*(s-a)),r=Math.min(e,i)-n,i=Math.max(e,i)+n,n=Math.min(a,s)-o,o=Math.max(a,s)+o,d?d.fitToBounds({x1:r,x2:i,y1:n,y2:o}):l&&p&&(u.pointer.zoomX=!0,u.pointer.zoomY=!0,u.zoom({originalEvent:t,xAxis:[{axis:l,min:r,max:i}],yAxis:[{axis:p,min:n,max:o}]})))})},o.prototype.getClusterDistancesFromPoint=function(t,e,a){for(var r=[],i=0;i<t.length;i++){var o=E(this,{x:e,y:a}),n=E(this,{x:t[i].posX,y:t[i].posY}),n=Math.sqrt(Math.pow(o.x-n.x,2)+Math.pow(o.y-n.y,2));r.push({clusterIndex:i,distance:n})}return r.sort(function(t,e){return t.distance-e.distance})},o.prototype.getPointsState=function(t,e,a){var r,i,o,n=e?h(e,a):[],s=h(t,a),l={};for(u=[],t.clusters.forEach(function(t){l[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){l[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),o=0;o<s.length;o++)r=s[o],i=n[o],r&&i&&r.parentStateId&&i.parentStateId&&l[r.parentStateId]&&-1===l[r.parentStateId].parentsId.indexOf(i.parentStateId)&&(l[r.parentStateId].parentsId.push(i.parentStateId),-1===u.indexOf(i.parentStateId)&&u.push(i.parentStateId));return l},o.prototype.markerClusterAlgorithms={grid:function(t,e,a,r){for(var i={},o=this.getGridOffset(),n=this.getScaledGridSize(r),s=0;s<t.length;s++){var l=E(this,{x:t[s],y:e[s]}),p=l.x-o.plotLeft,l=l.y-o.plotTop,p=Math.floor(p/n);i[p=Math.floor(l/n)+"-"+p]||(i[p]=[]),i[p].push({dataIndex:a[s],x:t[s],y:e[s]})}return i},kmeans:function(t,e,a,r){var i,o,n,s,l,p,u,d=this,h=[],c=[],f={},m=r.processedDistance||z.layoutAlgorithm.distance,x=r.iterations,g=0,y=!0,C=[];for(l in r.processedGridSize=r.processedDistance,s=d.markerClusterAlgorithms?d.markerClusterAlgorithms.grid.call(d,t,e,a,r):{})1<s[l].length&&(n=w(s[l]),h.push({posX:n.x,posY:n.y,oldX:0,oldY:0,startPointsLen:s[l].length,points:[]}));for(;y;){for(h.map(function(t){return t.points.length=0,t}),p=c.length=0;p<t.length;p++)i=t[p],o=e[p],((C=d.getClusterDistancesFromPoint(h,i,o)).length&&C[0].distance<m?h[C[0].clusterIndex].points:c).push({x:i,y:o,dataIndex:a[p]});for(u=0;u<h.length;u++)1===h[u].points.length&&(C=d.getClusterDistancesFromPoint(h,h[u].points[0].x,h[u].points[0].y))[1].distance<m&&(h[C[1].clusterIndex].points.push(h[u].points[0]),h[C[0].clusterIndex].points.length=0);for(y=!1,u=0;u<h.length;u++)n=w(h[u].points),h[u].oldX=h[u].posX,h[u].oldY=h[u].posY,h[u].posX=n.x,h[u].posY=n.y,(h[u].posX>h[u].oldX+1||h[u].posX<h[u].oldX-1||h[u].posY>h[u].oldY+1||h[u].posY<h[u].oldY-1)&&(y=!0);x&&(y=g<x-1),g++}return h.forEach(function(t,e){f["cluster"+e]=t.points}),c.forEach(function(t,e){f["noise"+e]=[t]}),f},optimizedKmeans:function(t,e,a,r){var i,o,n=this,s=(n.xAxis,n.yAxis,r.processedDistance||z.layoutAlgorithm.gridSize),l={},p=n.getRealExtremes(),u=(n.options.cluster||{}).marker;return!n.markerClusterInfo||n.initMaxX&&n.initMaxX<p.maxX||n.initMinX&&n.initMinX>p.minX||n.initMaxY&&n.initMaxY<p.maxY||n.initMinY&&n.initMinY>p.minY?(n.initMaxX=p.maxX,n.initMinX=p.minX,n.initMaxY=p.maxY,n.initMinY=p.minY,l=n.markerClusterAlgorithms?n.markerClusterAlgorithms.kmeans.call(n,t,e,a,r):{},n.baseClusters=null):(n.baseClusters||(n.baseClusters={clusters:n.markerClusterInfo.clusters,noise:n.markerClusterInfo.noise}),n.baseClusters.clusters.forEach(function(r){r.pointsOutside=[],r.pointsInside=[],r.data.forEach(function(t){var e=E(n,t),a=E(n,r);i=Math.sqrt(Math.pow(e.x-a.x,2)+Math.pow(e.y-a.y,2)),(o=(r.clusterZone&&r.clusterZone.marker&&r.clusterZone.marker.radius?r.clusterZone.marker:u&&u.radius?u:z.marker).radius)+(0<=s-o?s-o:o)<i&&Y(r.pointsOutside)?r.pointsOutside.push(t):Y(r.pointsInside)&&r.pointsInside.push(t)}),r.pointsInside.length&&(l[r.id]=r.pointsInside),r.pointsOutside.forEach(function(t,e){l[r.id+"_noise"+e]=[t]})}),n.baseClusters.noise.forEach(function(t){l[t.id]=t.data})),l}},o.prototype.preventClusterCollisions=function(t){var a,r,i,e,o,n,s,l,p,u,d,h=this,c=t.key.split("-").map(parseFloat),f=c[0],m=c[1],x=t.gridSize,g=t.groupedData,y=t.defaultRadius,C=t.clusterRadius,I=m*x,k=f*x,c=E(h,t),M=c.x,S=c.y,b=[],A=0,D=(h.options.cluster||{}).marker,v=(h.options.cluster||{}).zones,X=h.getGridOffset();for(M-=X.plotLeft,S-=X.plotTop,n=1;n<5;n++)for(e=n%2?-1:1,o=n<3?-1:1,e=Math.floor((M+e*C)/x),d=[(o=Math.floor((S+o*C)/x))+"-"+e,o+"-"+m,f+"-"+e],s=0;s<d.length;s++)-1===b.indexOf(d[s])&&d[s]!==t.key&&b.push(d[s]);b.forEach(function(t){if(g[t]){g[t].posX||(u=w(g[t]),g[t].posX=u.x,g[t].posY=u.y);var e=E(h,{x:g[t].posX||0,y:g[t].posY||0});if(r=e.x-X.plotLeft,i=e.y-X.plotTop,e=t.split("-").map(parseFloat),p=e[0],l=e[1],v)for(a=g[t].length,n=0;n<v.length;n++)a>=v[n].from&&a<=v[n].to&&(A=Y((v[n].marker||{}).radius)?v[n].marker.radius||0:(D&&D.radius?D:z.marker).radius);1<g[t].length&&0===A&&D&&D.radius?A=D.radius:1===g[t].length&&(A=y),u=C+A,A=0,l!==m&&Math.abs(M-r)<u&&(M=l-m<0?I+C:I+x-C),p!==f&&Math.abs(S-i)<u&&(S=p-f<0?k+C:k+x-C)}});c=P(h,{x:M+X.plotLeft,y:S+X.plotTop});return g[t.key].posX=c.x,g[t.key].posY=c.y,c},o.prototype.isValidGroupedDataObject=function(t){var e,a=!1;return!!D(t)&&(M(t,function(t){if(a=!0,b(t)&&t.length){for(e=0;e<t.length;e++)if(!D(t[e])||!t[e].x||!t[e].y)return void(a=!1)}else a=!1}),a)},o.prototype.getClusteredData=function(t,e){var a,r,i,o,n,s,l,p,u,d,h,c,f,m=this,x=[],g=[],y=[],C=[],I=[],k=0,M=Math.max(2,e.minimumClusterSize||2);if(A(e.layoutAlgorithm.type)&&!m.isValidGroupedDataObject(t))return S("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,m.chart),!1;for(f in t)if(t[f].length>=M){if(i=t[f],a=O(),n=i.length,e.zones)for(c=0;c<e.zones.length;c++)n>=e.zones[c].from&&n<=e.zones[c].to&&((d=e.zones[c]).zoneIndex=c,u=e.zones[c].marker,h=e.zones[c].className);for(p=w(i),s="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:p.x,y:p.y}:(s=m.options.marker||{},m.preventClusterCollisions({x:p.x,y:p.y,key:f,groupedData:t,gridSize:m.getScaledGridSize(e.layoutAlgorithm),defaultRadius:s.radius||3+(s.lineWidth||0),clusterRadius:u&&u.radius?u.radius:(e.marker||{}).radius||z.marker.radius})),c=0;c<n;c++)i[c].parentStateId=a;if(y.push({x:s.x,y:s.y,id:f,stateId:a,index:k,data:i,clusterZone:d,clusterZoneClassName:h}),x.push(s.x),g.push(s.y),I.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:v(e.marker,{states:e.states},u||{})}}),m.options.data&&m.options.data.length)for(c=0;c<n;c++)D(m.options.data[i[c].dataIndex])&&(i[c].options=m.options.data[i[c].dataIndex]);k++,u=null}else for(c=0;c<t[f].length;c++)r=t[f][c],a=O(),l=null,o=((m.options||{}).data||[])[r.dataIndex],x.push(r.x),g.push(r.y),r.parentStateId=a,C.push({x:r.x,y:r.y,id:f,stateId:a,index:k,data:t[f]}),l=o&&"object"==typeof o&&!b(o)?v(o,{x:r.x,y:r.y}):{userOptions:o,x:r.x,y:r.y},I.push({options:l}),k++;return{clusters:y,noise:C,groupedXData:x,groupedYData:g,groupMap:I}},o.prototype.destroyClusteredData=function(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},o.prototype.hideClusteredData=function(){var t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=u.map(function(t){return(e[t].point||{}).id||""});(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},o.prototype.generatePoints=function(){var t,e,a,r,i,o,n,s,l=this,p=l.chart,u=(p.mapView,l.xAxis,l.yAxis,l.options.cluster),d=l.getRealExtremes(),h=[],c=[],f=[];if(u&&u.enabled&&l.xData&&l.xData.length&&l.yData&&l.yData.length&&!p.polar){i=u.layoutAlgorithm.type,(o=u.layoutAlgorithm).processedGridSize=X(o.gridSize||z.layoutAlgorithm.gridSize,p.plotWidth),o.processedDistance=X(o.distance||z.layoutAlgorithm.distance,p.plotWidth);for(var m=o.kmeansThreshold||z.layoutAlgorithm.kmeansThreshold,x=o.processedGridSize/2,p=P(l,{x:0,y:0}),x=P(l,{x:x,y:x}),g=Math.abs(p.x-x.x),y=Math.abs(p.y-x.y),C=0;C<l.xData.length;C++)l.dataMaxX||(Y(e)&&Y(t)&&Y(r)&&Y(a)?k(l.yData[C])&&k(r)&&k(a)&&(e=Math.max(l.xData[C],e),t=Math.min(l.xData[C],t),r=Math.max(l.yData[C]||r,r),a=Math.min(l.yData[C]||a,a)):(e=t=l.xData[C],r=a=l.yData[C])),l.xData[C]>=d.minX-g&&l.xData[C]<=d.maxX+g&&(l.yData[C]||d.minY)>=d.minY-y&&(l.yData[C]||d.maxY)<=d.maxY+y&&(h.push(l.xData[C]),c.push(l.yData[C]),f.push(C));Y(e)&&Y(t)&&k(r)&&k(a)&&(l.dataMaxX=e,l.dataMinX=t,l.dataMaxY=r,l.dataMinY=a),m=(i=(A(i)?i:l.markerClusterAlgorithms?i&&l.markerClusterAlgorithms[i]?l.markerClusterAlgorithms[i]:h.length<m?l.markerClusterAlgorithms.kmeans:l.markerClusterAlgorithms.grid:function(){return!1}).call(this,h,c,f,o))&&l.getClusteredData(i,u),o=u.animation&&l.markerClusterInfo&&l.markerClusterInfo.pointsState&&l.markerClusterInfo.pointsState.oldState?((s=l.markerClusterInfo.pointsState.oldState)&&M(s,function(t){t.point&&t.point.destroy&&t.point.destroy()}),l.markerClusterInfo.pointsState.newState):{},i=l.xData.length,s=l.markerClusterInfo,m&&(l.processedXData=m.groupedXData,l.processedYData=m.groupedYData,l.hasGroupedData=!0,l.markerClusterInfo=m,l.groupMap=m.groupMap),L.apply(this),m&&l.markerClusterInfo&&((l.markerClusterInfo.clusters||[]).forEach(function(t){(n=l.points[t.index]).isCluster=!0,n.clusteredData=t.data,n.clusterPointsAmount=t.data.length,t.point=n,I(n,"click",l.onDrillToCluster)}),(l.markerClusterInfo.noise||[]).forEach(function(t){t.point=l.points[t.index]}),u.animation&&l.markerClusterInfo&&(l.markerClusterInfo.pointsState={oldState:o,newState:l.getPointsState(m,s,i)}),u.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else L.apply(this)},I(e,"render",function(){(this.series||[]).forEach(function(e){var t,a;e.markerClusterInfo&&(t=e.options.cluster,a=((e.markerClusterInfo||{}).pointsState||{}).oldState,(t||{}).animation&&e.markerClusterInfo&&0===e.chart.pointer.pinchDown.length&&"pan"!==((e.xAxis||{}).eventArgs||{}).trigger&&a&&Object.keys(a).length&&(e.markerClusterInfo.clusters.forEach(function(t){e.animateClusterPoint(t)}),e.markerClusterInfo.noise.forEach(function(t){e.animateClusterPoint(t)})))})}),I(r,"update",function(){if(this.dataGroup)return S("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),I(i,"destroy",o.prototype.destroyClusteredData),I(i,"afterRender",function(){var e=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(t){t.point&&t.point.graphic&&(t.point.graphic.addClass("highcharts-cluster-point"),e&&t.point&&(t.point.graphic.css({cursor:"pointer"}),t.point.dataLabel&&t.point.dataLabel.css({cursor:"pointer"})),Y(t.clusterZone)&&t.point.graphic.addClass(t.clusterZoneClassName||"highcharts-cluster-zone-"+t.clusterZone.zoneIndex))})}),I(r,"drillToCluster",function(t){var e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;A(e)&&e.call(this,t)}),I(l,"setExtremes",function(){var e,t=this.chart,a=0;t.series.forEach(function(t){t.markerClusterInfo&&(e=x((t.options.cluster||{}).animation),a=e.duration||0)}),g(function(){t.tooltip&&t.tooltip.destroy()},a)})}),e(t,"masters/modules/marker-clusters.src.js",[],function(){})});