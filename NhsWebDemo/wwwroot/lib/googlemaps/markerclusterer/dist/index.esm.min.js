/**
 * Minified by jsDelivr using Terser v5.10.0.
 * Original file: /npm/@googlemaps/markerclusterer@1.0.19/dist/index.esm.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{featureCollection,point}from"@turf/helpers";import clustersKmeans from"@turf/clusters-kmeans";import clustersDbscan from"@turf/clusters-dbscan";import SuperCluster from"supercluster";import equal from"fast-deep-equal/es6";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function __rest(t,e){var r={};for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&e.indexOf(s)<0&&(r[s]=t[s]);if(null!=t&&"function"==typeof Object.getOwnPropertySymbols){var o=0;for(s=Object.getOwnPropertySymbols(t);o<s.length;o++)e.indexOf(s[o])<0&&Object.prototype.propertyIsEnumerable.call(t,s[o])&&(r[s[o]]=t[s[o]])}return r}class Cluster{constructor({markers:t,position:e}){this.markers=t,e&&(e instanceof google.maps.LatLng?this._position=e:this._position=new google.maps.LatLng(e))}get bounds(){if(0!==this.markers.length||this._position)return this.markers.reduce(((t,e)=>t.extend(e.getPosition())),new google.maps.LatLngBounds(this._position,this._position))}get position(){return this._position||this.bounds.getCenter()}get count(){return this.markers.filter((t=>t.getVisible())).length}push(t){this.markers.push(t)}delete(){this.marker&&(this.marker.setMap(null),delete this.marker),this.markers.length=0}}const filterMarkersToPaddedViewport=(t,e,r,s)=>{const o=extendBoundsToPaddedViewport(t.getBounds(),e,s);return r.filter((t=>o.contains(t.getPosition())))},extendBoundsToPaddedViewport=(t,e,r)=>{const{northEast:s,southWest:o}=latLngBoundsToPixelBounds(t,e),n=extendPixelBounds({northEast:s,southWest:o},r);return pixelBoundsToLatLngBounds(n,e)},distanceBetweenPoints=(t,e)=>{const r=(e.lat-t.lat)*Math.PI/180,s=(e.lng-t.lng)*Math.PI/180,o=Math.sin(r/2)*Math.sin(r/2)+Math.cos(t.lat*Math.PI/180)*Math.cos(e.lat*Math.PI/180)*Math.sin(s/2)*Math.sin(s/2);return 6371*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))},latLngBoundsToPixelBounds=(t,e)=>({northEast:e.fromLatLngToDivPixel(t.getNorthEast()),southWest:e.fromLatLngToDivPixel(t.getSouthWest())}),extendPixelBounds=({northEast:t,southWest:e},r)=>(t.x+=r,t.y-=r,e.x-=r,e.y+=r,{northEast:t,southWest:e}),pixelBoundsToLatLngBounds=({northEast:t,southWest:e},r)=>{const s=new google.maps.LatLngBounds;return s.extend(r.fromDivPixelToLatLng(t)),s.extend(r.fromDivPixelToLatLng(e)),s};class AbstractAlgorithm{constructor({maxZoom:t=16}){this.maxZoom=t}noop({markers:t}){return noop(t)}}class AbstractViewportAlgorithm extends AbstractAlgorithm{constructor(t){var{viewportPadding:e=60}=t;super(__rest(t,["viewportPadding"])),this.viewportPadding=60,this.viewportPadding=e}calculate({markers:t,map:e,mapCanvasProjection:r}){return e.getZoom()>=this.maxZoom?{clusters:this.noop({markers:t,map:e,mapCanvasProjection:r}),changed:!1}:{clusters:this.cluster({markers:filterMarkersToPaddedViewport(e,r,t,this.viewportPadding),map:e,mapCanvasProjection:r})}}}const noop=t=>t.map((t=>new Cluster({position:t.getPosition(),markers:[t]})));class GridAlgorithm extends AbstractViewportAlgorithm{constructor(t){var{maxDistance:e=4e4,gridSize:r=40}=t;super(__rest(t,["maxDistance","gridSize"])),this.clusters=[],this.maxDistance=e,this.gridSize=r}cluster({markers:t,map:e,mapCanvasProjection:r}){return this.clusters=[],t.forEach((t=>{this.addToClosestCluster(t,e,r)})),this.clusters}addToClosestCluster(t,e,r){let s=this.maxDistance,o=null;for(let e=0;e<this.clusters.length;e++){const r=this.clusters[e],n=distanceBetweenPoints(r.bounds.getCenter().toJSON(),t.getPosition().toJSON());n<s&&(s=n,o=r)}if(o&&extendBoundsToPaddedViewport(o.bounds,r,this.gridSize).contains(t.getPosition()))o.push(t);else{const e=new Cluster({markers:[t]});this.clusters.push(e)}}}class NoopAlgorithm extends AbstractAlgorithm{constructor(t){super(__rest(t,[]))}calculate({markers:t,map:e,mapCanvasProjection:r}){return{clusters:this.cluster({markers:t,map:e,mapCanvasProjection:r}),changed:!1}}cluster(t){return this.noop(t)}}class KmeansAlgorithm extends AbstractViewportAlgorithm{constructor(t){var{numberOfClusters:e}=t;super(__rest(t,["numberOfClusters"])),this.numberOfClusters=e}cluster({markers:t,map:e}){const r=[];if(0===t.length)return r;const s=featureCollection(t.map((t=>point([t.getPosition().lng(),t.getPosition().lat()]))));let o;return o=this.numberOfClusters instanceof Function?this.numberOfClusters(t.length,e.getZoom()):this.numberOfClusters,clustersKmeans(s,{numberOfClusters:o}).features.forEach(((e,s)=>{r[e.properties.cluster]||(r[e.properties.cluster]=new Cluster({position:{lng:e.properties.centroid[0],lat:e.properties.centroid[1]},markers:[]})),r[e.properties.cluster].push(t[s])})),r}}const DEFAULT_INTERNAL_DBSCAN_OPTION={units:"kilometers",mutate:!1,minPoints:1};class DBScanAlgorithm extends AbstractViewportAlgorithm{constructor(t){var{maxDistance:e=200,minPoints:r=DEFAULT_INTERNAL_DBSCAN_OPTION.minPoints}=t;super(__rest(t,["maxDistance","minPoints"])),this.maxDistance=e,this.options=Object.assign(Object.assign({},DEFAULT_INTERNAL_DBSCAN_OPTION),{minPoints:r})}cluster({markers:t,mapCanvasProjection:e}){const r=featureCollection(t.map((t=>{const r=e.fromLatLngToContainerPixel(t.getPosition());return point([r.x,r.y])}))),s=[];return clustersDbscan(r,this.maxDistance,this.options).features.forEach(((e,r)=>{s[e.properties.cluster]||(s[e.properties.cluster]=[]),s[e.properties.cluster].push(t[r])})),s.map((t=>new Cluster({markers:t})))}}class SuperClusterAlgorithm extends AbstractAlgorithm{constructor(t){var{maxZoom:e,radius:r=60}=t,s=__rest(t,["maxZoom","radius"]);super({maxZoom:e}),this.superCluster=new SuperCluster(Object.assign({maxZoom:this.maxZoom,radius:r},s)),this.state={zoom:null}}calculate(t){let e=!1;if(!equal(t.markers,this.markers)){e=!0,this.markers=[...t.markers];const r=this.markers.map((t=>({type:"Feature",geometry:{type:"Point",coordinates:[t.getPosition().lng(),t.getPosition().lat()]},properties:{marker:t}})));this.superCluster.load(r)}const r={zoom:t.map.getZoom()};return e||this.state.zoom>this.maxZoom&&r.zoom>this.maxZoom||(e=e||!equal(this.state,r)),this.state=r,e&&(this.clusters=this.cluster(t)),{clusters:this.clusters,changed:e}}cluster({map:t}){return this.superCluster.getClusters([-180,-90,180,90],Math.round(t.getZoom())).map(this.transformCluster.bind(this))}transformCluster({geometry:{coordinates:[t,e]},properties:r}){if(r.cluster)return new Cluster({markers:this.superCluster.getLeaves(r.cluster_id,1/0).map((t=>t.properties.marker)),position:new google.maps.LatLng({lat:e,lng:t})});{const t=r.marker;return new Cluster({markers:[t],position:t.getPosition()})}}}class ClusterStats{constructor(t,e){this.markers={sum:t.length};const r=e.map((t=>t.count)),s=r.reduce(((t,e)=>t+e),0);this.clusters={count:e.length,markers:{mean:s/e.length,sum:s,min:Math.min(...r),max:Math.max(...r)}}}}class DefaultRenderer{render({count:t,position:e},r){const s=t>Math.max(10,r.clusters.markers.mean)?"#ff0000":"#0000ff",o=window.btoa(`\n  <svg fill="${s}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">\n    <circle cx="120" cy="120" opacity=".6" r="70" />\n    <circle cx="120" cy="120" opacity=".3" r="90" />\n    <circle cx="120" cy="120" opacity=".2" r="110" />\n  </svg>`);return new google.maps.Marker({position:e,icon:{url:`data:image/svg+xml;base64,${o}`,scaledSize:new google.maps.Size(45,45)},label:{text:String(t),color:"rgba(255,255,255,0.9)",fontSize:"12px"},title:`Cluster of ${t} markers`,zIndex:Number(google.maps.Marker.MAX_ZINDEX)+t})}}function extend(t,e){for(let r in e.prototype)t.prototype[r]=e.prototype[r]}class OverlayViewSafe{constructor(){extend(OverlayViewSafe,google.maps.OverlayView)}}var MarkerClustererEvents;!function(t){t.CLUSTERING_BEGIN="clusteringbegin",t.CLUSTERING_END="clusteringend",t.CLUSTER_CLICK="click"}(MarkerClustererEvents||(MarkerClustererEvents={}));const defaultOnClusterClickHandler=(t,e,r)=>{r.fitBounds(e.bounds)};class MarkerClusterer extends OverlayViewSafe{constructor({map:t,markers:e=[],algorithm:r=new SuperClusterAlgorithm({}),renderer:s=new DefaultRenderer,onClusterClick:o=defaultOnClusterClickHandler}){super(),this.markers=[...e],this.clusters=[],this.algorithm=r,this.renderer=s,this.onClusterClick=o,t&&this.setMap(t)}addMarker(t,e){this.markers.includes(t)||(this.markers.push(t),e||this.render())}addMarkers(t,e){t.forEach((t=>{this.addMarker(t,!0)})),e||this.render()}removeMarker(t,e){const r=this.markers.indexOf(t);return-1!==r&&(t.setMap(null),this.markers.splice(r,1),e||this.render(),!0)}removeMarkers(t,e){let r=!1;return t.forEach((t=>{r=this.removeMarker(t,!0)||r})),r&&!e&&this.render(),r}clearMarkers(t){this.markers.length=0,t||this.render()}render(){const t=this.getMap();if(t instanceof google.maps.Map&&this.getProjection()){google.maps.event.trigger(this,MarkerClustererEvents.CLUSTERING_BEGIN,this);const{clusters:e,changed:r}=this.algorithm.calculate({markers:this.markers,map:t,mapCanvasProjection:this.getProjection()});(r||null==r)&&(this.reset(),this.clusters=e,this.renderClusters()),google.maps.event.trigger(this,MarkerClustererEvents.CLUSTERING_END,this)}}onAdd(){this.idleListener=this.getMap().addListener("idle",this.render.bind(this)),this.render()}onRemove(){google.maps.event.removeListener(this.idleListener),this.reset()}reset(){this.markers.forEach((t=>t.setMap(null))),this.clusters.forEach((t=>t.delete())),this.clusters=[]}renderClusters(){const t=new ClusterStats(this.markers,this.clusters),e=this.getMap();this.clusters.forEach((r=>{1===r.markers.length?r.marker=r.markers[0]:(r.marker=this.renderer.render(r,t),this.onClusterClick&&r.marker.addListener("click",(t=>{google.maps.event.trigger(this,MarkerClustererEvents.CLUSTER_CLICK,r),this.onClusterClick(t,r,e)}))),r.marker.setMap(e)}))}}export{AbstractAlgorithm,AbstractViewportAlgorithm,Cluster,ClusterStats,DBScanAlgorithm,DefaultRenderer,GridAlgorithm,KmeansAlgorithm,MarkerClusterer,MarkerClustererEvents,NoopAlgorithm,SuperClusterAlgorithm,defaultOnClusterClickHandler,distanceBetweenPoints,extendBoundsToPaddedViewport,extendPixelBounds,filterMarkersToPaddedViewport,noop,pixelBoundsToLatLngBounds};
//# sourceMappingURL=/sm/452900d82689b84876d7f3b57a59673c3900942bf66ae8519ef32011fad948c0.map